#include <algorithm>
#include "board.h"

using namespace std;

Board::Board(unsigned int width, unsigned int height): 
  width(width), 
  height(height), 
  grid(height, vector<Cell>(width)),
  total_letters(0),
  total_covered(0)
{}

void Board::loadWords(istream &save) {
    char x, y, orientation_char;
    string word_str;

    while(save >> y >> x >> orientation_char >> word_str) {
        // If can't parse position, stop loading.
        if(x < 'a' || x > 'z' || y < 'A' || y > 'Z') break;
        Position position(x, y);
        
        Orientation orientation;
        if(orientation_char == 'H') orientation = Horizontal;
        else if(orientation_char == 'V') orientation = Vertical;
        else break; // If can't parse orientation, stop loading.

        Word word(position, orientation, word_str);

        // Word could be parsed so it is assumed to be valid.
        // It will always be valid if the stream comes from
        // a board file generated by 'BoardBuilder'.
        addWord(word);
    }
}

vector<char> Board::getLettersInBoard() const {
    vector<char> letters;
    // Go through all 'Cell's in this 'Board' and
    // fill the vector 'letters' with every letter
    // found.
    for(auto &row: grid) {
        for(auto &cell: row) {
            if(!cell.isEmpty()) letters.push_back(cell.getLetter());
        }
    }
    return letters;
}

unsigned int Board::countLetters() const {
    return total_letters;
}

bool Board::isFullyCovered() const {
    return total_covered == total_letters;
}

unsigned int Board::getHeight() const {
    return height;
}

unsigned int Board::getWidth() const {
    return width;
}

const Cell& Board::getCell(Position position) const {
    return grid[position.getY()][position.getX()];
}

void Board::addWord(Word &word) {
    Position position = word.getStart();
    Orientation orientation = word.getOrientation();

    Cell &start_cell = grid[position.getY()][position.getX()];
    // The first letter in a 'Word' already starts coverable.
    start_cell.allowMove(orientation);

    for(char letter: word) {
        Cell &cell = grid[position.getY()][position.getX()];
        // Only increases letter count if letter didn't exist before.
        if(cell.isEmpty()) total_letters += 1;
        cell.setLetter(letter);
        position.stepForward(orientation);
    }
}

Word Board::findWord(Position position, Orientation orientation) const {
    // Find the start of the word by stepping backwards
    // until a letter is not found.
    while(position.inLimits(width, height) && !getCell(position).isEmpty()) {
        position.stepBackwards(orientation);
    }

    // 'Position' right now points to the place where a letter
    // wasn't found. Must step forward to be at the start of the 'Word'.
    position.stepForward(orientation);
    Position start = position;

    // Read 'Word' until the end to get its full string.
    string word;
    while(position.inLimits(width, height) && !getCell(position).isEmpty()) {
        word.push_back(getCell(position).getLetter());
        position.stepForward(orientation);
    }

    return Word(start, orientation, word);
}

void Board::cover(Position position, vector<Word> &completed_words) {
    Cell &cell = grid[position.getY()][position.getX()];

    cell.cover();
    total_covered += 1;

    // Unlock (make coverable) the next 'Cell' horizontally, if applicable
    if(cell.propagatesHorizontally()) {
        if(!propagate(position, Horizontal)) {
            // If propagation didn't happen although 'Cell'
            // 'propagatesHorizontally', it's because the end
            // of the 'Word' was reached.
            completed_words.push_back(findWord(position, Horizontal));
        }
    }

    // Unlock (make coverable) the next 'Cell' vertically, if applicable
    if(cell.propagatesVertically()) {
        if(!propagate(position, Vertical)) {
            // If propagation didn't happen although 'Cell'
            // 'propagatesVertically', it's because the end
            // of the 'Word' was reached.
            completed_words.push_back(findWord(position, Vertical));
        }
    }
}

bool Board::propagate(Position position, Orientation orientation) {
    Cell *cell;
    // First, try to find a 'Cell' ahead of 'position' that
    // is not yet covered.
    do {
        position.stepForward(orientation);
        // Out of limits means such 'Cell' couldn't be found.
        if(!position.inLimits(width, height)) return false;
        cell = &grid[position.getY()][position.getX()];
    } while(cell->isCovered());

    // Cell was found. If it is not empty, it should be made
    // coverable.
    if(!cell->isEmpty()) {
        cell->allowMove(orientation);
    }

    return !cell->isEmpty();
}

const Cell* Board::getNextUncoveredCell(Position position, Orientation orientation) const {
    const Cell *cell;
    // First, try to find a 'Cell' ahead of 'position' that
    // is not yet covered.
    // This algorithm is very similar to the one found in
    // 'propagate', but notice in this case it happens in
    // a 'const' context: the 'Cell' won't be modified.
    do {
        position.stepForward(orientation);
        // Out of limits means such 'Cell' couldn't be found.
        if(!position.inLimits(width, height)) return nullptr;
        cell = &getCell(position);
    } while(cell->isCovered());

    // Cell only belongs to the 'Word' if it is non-empty.
    if(cell->isEmpty()) {
        return nullptr;
    }

    return cell;
}

bool Board::hasMove(const Hand &hand) const {
    for(auto &row: grid) {
        for(auto &cell: row) {
            char letter = cell.getLetter();
            if(cell.isCoverable() && hand.hasLetter(letter)) return true;
        }
    }

    // No cell can currently be covered with 'hand'.
    return false;
}

bool Board::mustPlayTwiceEdgeCase(const Hand &hand, vector<Position> &legal_positions) {
    // This edge case happens when:
    // 1- All possible moves are with the same letter
    // 2- Player has just one such letter in hand
    // 3- At least one of the moves unlocks a cell that the player can cover
    //
    // When all these conditions are met, only moves that respect '3' are legal
    // because moves that don't respect '3' would block the player from covering
    // a cell in the next move: rules say that players must always move
    // twice per turn whenever possible.

    char letter = 0; // in this context, 0 means 'unknown' 
    for(unsigned int j = 0; j < height; j++) {
        for(unsigned int i = 0; i < width; i++) {
            Cell &cell = grid[j][i];

            if(!cell.isCoverable() || !hand.hasLetter(cell.getLetter())) {
                // Skip cells that aren't possible moves anyway.
                continue;
            }

            if(!letter) { // If letter was still 'unknown'
                letter = cell.getLetter();
                // Check condition '2'
                if(hand.countLetter(letter) >= 2) return false;
            } else if(letter != cell.getLetter()) { // Check condition '1'
                return false; 
            }

            // Check condition '3'
            Position position((int) i, (int) j);

            if(cell.propagatesHorizontally()) {
                // See if 'cell' would uncover another that 'hand'
                // can cover in the second move.
                const Cell *next_cell = getNextUncoveredCell(position, Horizontal);
                if(next_cell) {
                    char next_letter = next_cell->getLetter();

                    if(next_letter != letter && hand.hasLetter(next_letter)) {
                        // Yes, it would, so this is a legal position
                        // in this edge case.
                        legal_positions.push_back(position);
                    }
                }
            }

            if(cell.propagatesVertically()) {
                // See if 'cell' would uncover another that 'hand'
                // can cover in the second move.
                const Cell *next_cell = getNextUncoveredCell(position, Vertical);
                if(next_cell) {
                    char next_letter = next_cell->getLetter();

                    if(next_letter != letter && hand.hasLetter(next_letter)) {
                        // Yes, it would, so this is a legal position
                        // in this edge case.
                        legal_positions.push_back(position);
                    }
                }
            }
        }
    }

    // If there are any 'legal_positions' under this edge case, they are enforced.
    // Otherwise, it means that the player really can only make one move this turn
    // (because condition 3 isn't met), so the edge case doesn't apply.
    return !legal_positions.empty();
}
