#include "board.h"

using namespace std;

Board::Board(unsigned int width, unsigned int height): 
  width(width), 
  height(height), 
  grid(height, vector<Cell>(width)),
  total_letters(0)
{}

void Board::loadWords(istream &save) {
    char x, y, orientation_char;
    string word_str;

    while(save >> y >> x >> orientation_char >> word_str) {
        // If can't parse position, stop loading.
        if(x < 'a' || x > 'z' || y < 'A' || y > 'Z') break;
        Position position(x, y);
        
        Orientation orientation;
        if(orientation_char == 'H') orientation = Horizontal;
        else if(orientation_char == 'V') orientation = Vertical;
        else break; // If can't parse orientation, stop loading.

        Word word(position, orientation, word_str);

        // Word could be parsed so it is assumed to be valid.
        // It will always be valid if the stream comes from
        // a board file generated by this program.
        addWord(word);
    }
}

unsigned int Board::countLetters() const {
    return total_letters;
}

unsigned int Board::countWords() const {
    return (unsigned int) words.size();
}

unsigned int Board::getHeight() const {
    return height;
}

unsigned int Board::getWidth() const {
    return width;
}

const Cell& Board::getCell(Position position) const {
    return grid[position.getY()][position.getX()];
}

void Board::addWord(const Word &word) {
    Position position = word.getStart();
    Orientation orientation = word.getOrientation();

    for(char letter: word) {
        Cell &cell = grid[position.getY()][position.getX()];
        // Only increases letter count if letter didn't exist before.
        if(cell.isEmpty()) total_letters += 1;
        cell.setLetter(letter);
        position.stepForward(orientation);
    }

    words.push_back(move(word));
}

bool Board::isWordValid(const Word &word, ostream &error_messages) const {
    Position position = word.getStart();
    Orientation orientation = word.getOrientation();

    // Check if starting position is inside the board.
    if(!position.inLimits(width, height)) {
        error_messages << "Position '" << position << "' is outside the board.\n";
        return false;
    }

    // For the word to start at this position, it must not have a letter immediately behind.
    // Otherwise, the beginning would be ambiguous.
    position.stepBackwards(orientation);
    if(position.inLimits(width, height) && !getCell(position).isEmpty()) {
        position.stepForward(orientation);
        error_messages << "Word would be adjacent to existing word at '" << position << "', creating ambiguity.\n";
        return false;
    }

    // Assume word already exists, if at least one of the cells is empty 
    // this variable will become false.
    bool word_already_exists = true;

    for(char current_letter: word) {
        position.stepForward(orientation);

        // Every letter must be inside the board
        if(!position.inLimits(width, height)) {
            position.stepBackwards(orientation);
            error_messages << "Word goes outside the board after position '" << position << "'.\n";
            return false;
        }

        const Cell &current_cell = getCell(position);
        if(current_cell.isEmpty()) {
            // One empty cell is enough to make sure this 'Word' didn't already exist.
            word_already_exists = false;
            std::pair<Position, Position> laterals = position.laterals(orientation);

            // If cell was empty, this 'Word' isn't crossing any other at this position.
            // This means that laterally adjacent cells must be empty, otherwise it
            // would be ambiguous.
            if(laterals.first.inLimits(width, height) && !getCell(laterals.first).isEmpty()) {
                error_messages << "Word would be adjacent to existing word at '" << laterals.first << "', creating ambiguity.\n";
                return false;
            }
            if(laterals.second.inLimits(width, height) && !getCell(laterals.second).isEmpty()) {
                error_messages << "Word would be adjacent to existing word at '" << laterals.second << "', creating ambiguity.\n";
                return false;
            }
        } else if(current_cell.getLetter() != current_letter) { // 'Word' may only cross a non-empty cell if letter matches.
            error_messages << "Word's letter '" << current_letter << "' intersects with existing letter '" 
                    << current_cell.getLetter() << "' at position '" << position << "'.\n";
            return false;
        }
    }

    // For the word to end at this position, it must not have a letter immediately ahead.
    // Otherwise, the ending would be ambiguous.
    position.stepForward(orientation);
    if(position.inLimits(width, height) && !getCell(position).isEmpty()) {
        position.stepBackwards(orientation);
        error_messages << "Word would be adjacent to existing word at '" << position << "', creating ambiguity.\n";
        return false;
    }

    // It only makes sense to place a 'Word' if it didn't exist in this exact position before.
    if(word_already_exists) {
        error_messages << "This word has already been placed in board at that position.\n";
        return false;
    }

    return true;
}

void Board::writeData(ostream &out) const {
    // Write the dimensions of the board on the first line.
    out << height << " x " << width << endl;

    // Write the list of 'Word's over the next lines (one in each line).
    for(const Word &word: words) {
        out << word << endl;
    }

    // Write a 2D representation of the board at the end.
    // This is similar to 'BoardBuilder::printBoard'. However, this
    // function doesn't call setcolor and prints an extra space between
    // cells and the row identifiers on the left of the board.
    out << endl << "  ";
    for(unsigned int i = 0; i < width; i++) {
        char letter = (char) i + 'a';
        out << letter << ' ';
    }
    out << endl;

    for(unsigned int j = 0; j < height; j++) {
        char letter = (char) j + 'A';
        out << letter << ' ';

        for(unsigned int i = 0; i < width; i++) {
            out << grid[j][i];
            
            if(i+1 != width) {
                out << ' ';
            }
        }
        out << endl;
    }
}
